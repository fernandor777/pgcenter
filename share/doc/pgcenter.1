.TH PGCENTER 1 "August, 2015"
.SH NAME
pgcenter \- is the PostgreSQL administration console with top-like monitoring.
.SH SYNOPSIS
.B pgcenter
.RI "[OPTION]... [DBNAME [USERNAME]]"
.br
.SH DESCRIPTION
.B PostgreSQL
provides various statistics which includes information about tables, indexes, functions and other database objects and their usage. Moreover, statistics has information about connections, current queries and database operations (INSERT/DELETE/UPDATE). But most of this statistics are provided as permanently incremented counters. The
.B pgcenter
provides convenient interface to this statistics and allow viewing statistics changes in time interval, eg. per second. The 
.B pgcenter
provides fast access for database management task, such as editing configuration files, reloading services, viewing log files and canceling or terminating database backends (by pid or using state mask). However if need execute some specific operations, pgcenter can start psql session for this purposes.

.B pgcenter
uses 
.IR tabs
and
.IR contexts .
Tab is a main area for displaying statistics which include 1) summary system stats, 2) summary postgres stats, 3) main postgres stats, 4) aux system/postgres stats (optionally). One tab uses one connection to postgres. Number of tabs limited by eight, so it's possible to work with eight postgreses. Context is the type of displayed statistics: table statistics, index statistics, functions statistics, replication statistics, etc. Only one context can be active. Contexts can be switched using hotkeys.

All operations in pgcenter realized through hotkeys.

When 
.B pgcenter
starts it using the connection parameters transmitted directly through the arguments, or use a connection file that describes the connections options. For each connection a separate tab is allocated. When the arguments and connections file used together, connect options from arguments always starts in the first tab. If the arguments or connections file is not specified, 
.B pgcenter
uses default connection settings.

The
.B pgcenter
main window divided into 3 window:
.IR SUMMARY , 
.IR CMDLINE ,
.I DBRESULT
and optional
.I LOGTAIL
window which hidden by default and appears only by user command.

.SH COMMAND-LINE OPTIONS
The command-line syntax for pgcenter consists of:
.IP "-h, --host=HOSTNAME"
PostgreSQL server host or socket directory (default: "/tmp").
.IP "-p, --port=PORT"
PostgreSQL server port (default: "5432").
.IP "-U, --username=USERNAME"
PostgerSQL user name (default: "current logged user").
.IP "-d, --dbname=DBNAME"
PostgreSQL administrative database name (default: "pgbouncer").
.IP "-f, --file=FILENAME"
Use connections information from file. By default, pgcenter when starting, trying read 
.IR ~/.pgcenterrc
connections file. This behaviour can be overriden with this option.
.IP "-w, --no-password"
Never prompt for password.
.IP "-W, --password"
Force password prompt (should happen automatically).
.IP "-?, --help"
Show this help, then exit.
.IP "-V, --version"
Print version, then exit.

.SH SUMMARY WINDOW
Summary window always displayed and provides various information about system load and current connected PostgreSQL.

.IP "\fBCurrent Time and Load Average\fR"
Line 1-1 shows program name, current time, system load avg over the last 1, 5 and 15 minutes.

.IP "\fBCPU Usage\fR"
Line 1-2 shows CPU usage percentages based on the interval since the last refresh.

.B "us, user"
.RS
.RS
Percentage of CPU utilization that occurred while executing at the user level (application).
.RE

.B "sy, system"
.RS 
Percentage of CPU utilization that occurred while executing at the system level (kernel).
.RE

.B "ni, nice"
.RS
Percentage of CPU utilization that occurred while executing at the user level with nice priority.
.RE

.B "id, idle"
.RS
Percentage of time that the CPU or CPUs were idle and the system did not have an outstanding disk I/O request.
.RE

.B "wa, iowait"
.RS
Percentage of time that the CPU or CPUs were idle during which the system had an outstanding disk I/O request.
.RE

.B "hi, hardirq"
.RS
Percentage of time that the CPU or CPUS spent servicing hardware interrupts.
.RE

.B "si, softirq"
.RS
Percentage of time thatthe CPU or CPUS spent servicing software interrupts.
.RE

.B "st, steal"
.RS
Percentage of time spent in involuntary wait by the virtual CPU or CPUs while the hypervisor was servicing another virtual processor.
.RE
.RE

.IP "\fBCPU Usage\fR"
Line 1-3 shows memory and line 1-4 shows swap usage based on the interval since the last refresh.

.B "total"
.RS
.RS
Total amount of RAM or swap in MiB (mebibyte = 1024 KiB = 1,048,576 bytes).
.RE

.B "free"
.RS 
Total amount of free RAM or swap in MiB (mebibyte = 1024 KiB = 1,048,576 bytes).
.RE

.B "used"
.RS 
Total amount of used RAM or swap in MiB (mebibyte = 1024 KiB = 1,048,576 bytes).
.RE

.B "buff/cached"
.RS 
Total amount of cached and buffered RAM in MiB (mebibyte = 1024 KiB = 1,048,576 bytes).
.RE

.B "dirty/writeback"
.RS
Total ammount of dirty memory which is waiting to be written back to the disk. And total amount of memory actively being written back to the disk. Values are in MiB (mebibyte = 1024 KiB = 1,048,576 bytes).
.RE
.RE

.IP "\fBConnection information\fR"
Line 2-1 shows connection information to the current PostgreSQL:

.B conn
.RS
.RS
Current tab number (from 1 to 8) and connection status.
.RE

.B conninfo
.RS
Current connection information with following format:
.B host:port
.BR username@dbname .
.RE

.B "postgresql version"
.RS
Version of the PostgreSQL.
.RE

.B uptime
.RS
Uptime of PostgreSQL service.
.RE
.RS
Used query: SELECT now() - pg_postmaster_start_time();
.RE
.RE

.IP "\fBSummary activity\fR"
Line 2-2 shows current PostgreSQL connections grouped by their states. Information about connections are get from pg_stat_activity and pg_prepared_xacts.

.RS
.B conns
.RS
Information about connected clients, total and max available (specified in max_connections).
.RE

.B prepared
.RS
Information about prepared transactions, total and max available (specified in max_prepared_reansactions).
.RE

.B idle
.RS
Number of backends in \fBidle\fR state which is waiting for a new client command.
.RE

.B idle_in_xact
.RS
Number of backends in \fBidle in transaction\fR means the backend is in a transaction, but is not currently executing a query, and \fBidle in transaction (aborted)\fR which is similar to idle in transaction, except one of the statements in the transaction caused an error.
.RE

.B active
.RS
Number of backends in \fBactive\fR state when backends is executing a queries.
.RE

.B waiting
.RS
Number of backends which is currently waiting on a lock. This value is based on pg_stat_activity and depends on PostgreSQL version. In PostgreSQL versions before 9.5 it accounts number of connections with "pg_stat_activity.waiting = true". In version 9.6 waiting column has been replaced with wait_event and wait_event_type columns and pgcenter accounts connections with "pg_stat_activity.wait_event IS NOT NULL". In PostgreSQL 10, number of possible values of wait_event and wait_event_type has been extended and rule of accounting becomes inaccurate, so since version 10 waiting connections accounts with "pg_stat_activity.wait_event_type = 'Lock'" condition.
.RE

.B others
.RS
Number of backends with \fBfastpath function call\fR state which executes fast-path functions and \fBdisabled\fR state which is reported only if \fItrack_activities\fR is disabled in backend.
.RE
.RE

.IP "\fBAutovacuum activity\fR"
Line 2-3 shows current PostgreSQL autovacuum activity.

.B workers
.RS
.RS
Total number of autovacuum workers currently running.
.RE

.B max
.RS
Max number of allowed autovacuum workers.
.RE

.B manual
.RS
Total number of vacuum workers started by user.
.RE

.B wraparound
.RS
Total number of workers currently running and perform anti wraparound vacuum.
.RE

.B avw_maxtime
.RS
Execution time of the oldest autovacuum or user-started worker.
.RE
.RE

.IP "\fBStatements activity\fR"
Line 2-4 shows statements activity. Some information provided by
.I pg_stat_statements
contrib module which not installed by default. For proper work,
.I pg_stat_statements
must be installed into database. For more information see URLS sections below.

.B stmt/s
.RS
.RS
Number of statements per second. This value calculated as difference between two values within 1 second interval.
.RE
.RS
.nf
Used query: SELECT sum(calls) FROM pg_stat_statements;
.fi
.RE

.B stmt_avgtime
.RS
Average queries duration in milisecond. Result defines here present the average time since the start of statistics collection. Therefore, to obtain a result that corresponds to the current time, pg_stat_statements statistics should be periodically reset (once a day, for example).
.RE
.RS
.nf
Used query: SELECT (sum(total_time) / sum(calls))::numeric(6,3) AS avg_query FROM pg_stat_statements;
.fi
.RE

.B xact_maxtime
.RS
Execution time of the oldest transaction (not a query or session).
.RE
.RS
.nf
Used query: SELECT coalesce(date_trunc('seconds', max(now() - xact_start)), '00:00:00') FROM pg_stat_activity;
.fi
.RE

.B prep_maxtime
.RS
Execution time of the oldest prepared transaction (not a query or session).
.RE
.RS
.nf
Used query: SELECT coalesce(date_trunc('seconds', max(now() - prepared)), '00:00:00') FROM pg_prepared_xacts;
.fi
.RE
.RE

.SH CMDLINE WINDOW
Cmdline window used for displaying diagnostic messages or when need additional input from user.

.SH DBRESULT WINDOW
Dbresult window used for displaying statistics from PostgreSQL. Here 
.I pgcenter
uses statistics contexts, which determines what type of statistics will be shown.

.IP "\fBpg_stat_database context\fR"
Statistics from
.I pg_stat_database
system view which show database-wide statistics. Note, when new database created or existing database dropped,
.I pgcenter
resets it's own counters (not postgresql statistics counters) to zero.
.nf
Used query: SELECT 
                datname, 
                xact_commit AS commit, xact_rollback AS rollback, 
                blks_read AS reads, blks_hit AS hits,
                tup_returned AS returned, tup_fetched AS fetched, 
                tup_inserted AS inserts, tup_updated AS updates, tup_deleted AS deletes, 
                conflicts, deadlocks, 
                temp_files AS tmp_files, temp_bytes AS tmp_bytes, 
                blk_read_time AS read_t, blk_write_time AS write_t,
                date_trunc('seconds', now() - stats_reset) as stats_age 
            FROM pg_stat_database ORDER BY datname;
.fi

.B datname
.RS
.RS
Name of this database.
.RE

.B commit
.RS
Number of transactions per second in this database that have been committed.
.RE

.B rollback
.RS
Number of transactions per second in this database that have been rolled back.
.RE

.B reads
.RS
Number of disk blocks read per second in this database.
.RE

.B hits
.RS
Number of times per second when disk blocks were found already in the buffer cache, so that a read was not necessary (this only includes hits in the PostgreSQL buffer cache, not the operating system's file system cache).
.RE

.B returned
.RS
Number of rows returned by queries in this database (per second).
.RE

.B fetched
.RS
Number of rows fetched by queries in this database (per second).
.RE

.B inserts
.RS
Number of rows inserted by queries in this database (per second).
.RE

.B updates
.RS
Number of rows updated by queries in this database (per second).
.RE

.B deletes
.RS
Number of rows deleted by queries in this database (per second).
.RE

.B conflicts
.RS
Number of queries per second canceled due to conflicts with recovery in this database. Conflicts occur only on standby servers.
.RE

.B deadlocks
.RS
Number of deadlocks detected in this database (per second).
.RE

.B tmp_files
.RS
Number of temporary files created by queries in this database (pre second). All temporary files are counted, regardless of why the temporary file was created (e.g., sorting or hashing), and regardless of the
.I log_temp_files
setting.
.RE

.B tmp_bytes
.RS
Total amount of data written to temporary files by queries in this database (per second). All temporary files are counted, regardless of why the temporary file was created, and regardless of the
.I log_temp_files
setting.
.RE

.B read_t
.RS
Time spent reading data file blocks by backends in this database, in milliseconds.
.RE

.B write_t
.RS
Time spent writing data file blocks by backends in this database, in milliseconds.
.RE

.B stats_age
.RS
Age of stats collected by server.
.RE
.RE

.IP "\fBpg_stat_replication context\fR"
Statistics from
.I pg_stat_replication
system view which will contain one row per WAL sender process, showing statistics about replication to that sender's connected standby server. Only directly connected standbys are listed; no information is available about downstream standby servers.
.nf
Used query: SELECT
                client_addr AS client, usename AS user, application_name AS name,
                state, sync_state AS mode,
                (pg_xlog_location_diff(pg_current_xlog_location(),'0/0') / 1024)::bigint as pending,
                (pg_xlog_location_diff(pg_current_xlog_location(),sent_location) / 1024)::bigint as pending,
                (pg_xlog_location_diff(sent_location,write_location) / 1024)::bigint as write,
                (pg_xlog_location_diff(write_location,flush_location) / 1024)::bigint as flush,
                (pg_xlog_location_diff(flush_location,replay_location) / 1024)::bigint as replay,
                date_trunc('seconds', write_lag) as write_lag,
                date_trunc('seconds', flush_lag) as flush_lag,
                date_trunc('seconds', replay_lag) as replay_lag,
                (pg_xlog_location_diff(pg_current_xlog_location(),replay_location))::bigint / 1024 as total_lag,
                (pg_last_committed_xact()).xid::text::bigint - backend_xmin::text::bigint as xact_age,
                date_trunc('seconds', (pg_last_committed_xact()).timestamp - pg_xact_commit_timestamp(backend_xmin)) as time_age
            FROM pg_stat_replication"
.fi

.B client
.RS
.RS
IP address of the client connected to this WAL sender. If this field is null, it indicates that the client is connected via a Unix socket on the server machine.
.RE

.B user
.RS
Name of the user logged into this WAL sender process.
.RE

.B name
.RS
Name of the application that is connected to this WAL sender.
.RE

.B state
.RS
Current WAL sender state.
.RE

.B mode
.RS
Synchronous state of this standby server.
.RE

.B xlog
.RS
Amount of the transaction logs in kilobytes, currently generated by postgres (per second).
.RE

.B pending
.RS
Difference between XLOG current position and XLOG sent position, shows amount of XLOG in kilobytes which should be sent over network.
.RE

.B write
.RS
Difference between XLOG sent position and XLOG write position, shows amount of XLOG in kilobytes which sent over network, but not written yet on remote host.
.RE

.B flush
.RS
Difference between XLOG write position and XLOG flush position, shows amount of XLOG in kilobytes which written, but not flushed yet on remote host.
.RE

.B replay
.RS
Difference between XLOG flush position and XLOG replay position, shows amount of XLOG in kilobytes which flushed, but not replayed yet on remote host.
.RE

.B total_lag
.RS
Difference between XLOG current position on the master server and XLOG replay position onremote host, shows the total amount of XLOG in kilobytes, the standby is behind.
.RE

.B write_lag
.RS
Time elapsed between flushing recent WAL locally and receiving notification that this standby server has written it (but not yet flushed it or applied it). This can be used to gauge the delay that synchronous_commit level remote_write incurred while committing if this server was configured as a synchronous standby. Available since PostgreSQL 10.
.RE

.B flush_lag
.RS
Time elapsed between flushing recent WAL locally and receiving notification that this standby server has written and flushed it (but not yet applied it). This can be used to gauge the delay that synchronous_commit level remote_flush incurred while committing if this server was configured as a synchronous standby. Available since PostgreSQL 10.
.RE

.B replay_lag
.RS
Time elapsed between flushing recent WAL locally and receiving notification that this standby server has written, flushed and applied it. This can be used to gauge the delay that synchronous_commit level remote_apply incurred while committing if this server was configured as a synchronous standby. Available since PostgreSQL 10.
.RE

.B xact_age
.RS
Age (measured in transactions) of the longest query currently running on the connected standby server. This available since 9.5 version and requires enabled options \fBhot_standby_feedback\fR and \fBtrack_commit_timestamp\fR to on. An update interval also depends on \fBwal_receiver_status_interval\fR value, which is 10 seconds by default. High values here mean that there is an active query on the standby which may potentially cause replication lag or defer autovacuum and that able to causes bloat of tables and indexes. 
.RE

.B time_age
.RS
Age (measured in time) of the longest query currently running on the connected standby server. This available since 9.5 version and requires enabled options \fBhot_standby_feedback\fR and \fBtrack_commit_timestamp\fR to on. An update interval also depends on \fBwal_receiver_status_interval\fR value, which is 10 seconds by default. This metric is similar to xact_age but pronounced in human-understandable time and shows real age of the longest query running on the standby. It can be used with xact_age, when xact_age is high, recheck time_age and if time_age is low, probably there is no problem.
.RE
.RE

.IP "\fBpg_stat_tables context\fR"
Statistics from
.I pg_stat_user_tables
or
.I pg_stat_all_tables
views which will contain one row for each table in the current database (including TOAST tables), showing statistics about accesses to that specific table.
.I pg_stat_user_tables
used by default, and 
.I pgcenter 
can be switched to
.I pg_stat_all_tables
using
.B ,
hotkey.
.nf
Used query: SELECT
                schemaname || '.' || relname AS relation,
                seq_scan, seq_tup_read AS seq_read,
                idx_scan, idx_tup_fetch AS idx_fetch,
                n_tup_ins AS inserts, n_tup_upd AS updates,
                n_tup_del AS deletes, n_tup_hot_upd AS hot_updates,
                n_live_tup AS live, n_dead_tup AS dead
            FROM pg_stat_user_tables ORDER BY 1;
.fi

.B relation
.RS
.RS
Name of this table including schemaname.
.RE

.B seq_scan
.RS
Number of sequential scans initiated on this table (per second).
.RE

.B seq_read
.RS
Number of live rows fetched by sequential scans (per second).
.RE

.B idx_scan
.RS
Number of index scans initiated on this table (per second).
.RE

.B idx_fetch
.RS
Number of live rows fetched by index scans (per second).
.RE

.B inserts
.RS
Number of rows inserted (per second).
.RE

.B updates
.RS
Number of rows updated (per second).
.RE

.B deletes
.RS
Number of rows deleted (per second).
.RE

.B hot_updates
.RS
Number of rows HOT updated means with no separate index update required (per second).
.RE

.B live
.RS
Estimated number of live rows (per second).
.RE

.B dead
.RS
Estimated number of dead rows (per second).
.RE
.RE

.IP "\fBpg_statio_tables context\fR"
Show statistics from
.I pg_statio_user_tables
or
.I pg_statio_all_tables 
views which showing statistics about I/O on that specific table in the current database. 
.I pg_statio_user_tables
used by default, and 
.I pgcenter
can be switched to 
.I pg_statio_all_tables
using 
.B , 
hotkey.
.nf
Used query: SELECT
                schemaname ||'.'|| relname AS relation,
                heap_blks_read * (SELECT current_setting('block_size')::int / 1024) AS heap_read,
                heap_blks_hit * (SELECT current_setting('block_size')::int / 1024) AS heap_hit,
                idx_blks_read * (SELECT current_setting('block_size')::int / 1024) AS idx_read,
                idx_blks_hit * (SELECT current_setting('block_size')::int / 1024) AS idx_hit,
                toast_blks_read * (SELECT current_setting('block_size')::int / 1024) AS toast_read,
                toast_blks_hit * (SELECT current_setting('block_size')::int / 1024) AS toast_hit,
                tidx_blks_read * (SELECT current_setting('block_size')::int / 1024) AS tidx_read,
                tidx_blks_hit * (SELECT current_setting('block_size')::int / 1024) AS tidx_hit
            FROM pg_statio_user_tables ORDER BY 1;
.fi

.B relation
.RS
.RS
Name of this table including schemaname.
.RE

.B heap_read
.RS
Number of data read from disk related to this table in kilobytes per second.
.RE

.B heap_hit
.RS
Number of buffer hits in this table in kilobytes per second.
.RE

.B idx_read
.RS
Number of data read from disk in kilobytes per second related to all indexes on this table.
.RE

.B idx_hit
.RS
Number of buffer hits in all indexes on this table in kilobytes per second.
.RE

.B toast_read
.RS
Number of data read from disk in kilobytes per second from this table's TOAST table (if any).
.RE

.B toast_hit
.RS
Number of buffer hits in this table's TOAST table (if any) in kilobytes per second.
.RE

.B tidx_read
.RS
Number of data read from disk in kilobytes per second from this table's TOAST table indexes (if any).
.RE

.B tidx_hit
.RS
Number of buffer hits in this table's TOAST table indexes (if any) in kilobytes per second.
.RE
.RE

.IP "\fBpg_stat_indexes context\fR"
Show statistics from
.I pg_stat_user_indexes
and
.I pg_statio_user_indexes
(or
.I pg_stat_all_indexes
and
.IR pg_statio_all_indexes ).
The 
.I pg_stat_user_indexes
view will contain one row for each index in the current database, showing statistics about accesses to that specific index.
.I pg_statio_user_indexes
view will contain one row for each index in the current database, showing statistics about I/O on that specific index. 

Note: Indexes can be used via either simple index scans or "bitmap" index scans. In a bitmap scan the output of several indexes can be combined via AND or OR rules, so it is difficult to associate individual heap row fetches with specific indexes when a bitmap scan is used. Therefore, a bitmap scan increments the 
.I pg_stat_all_indexes.idx_tup_read 
count(s) for the index(es) it uses, and it increments the 
.I pg_stat_all_tables.idx_tup_fetch 
count for the table, but it does not affect 
.IR pg_stat_all_indexes.idx_tup_fetch .
The 
.I idx_tup_read 
and 
.I idx_tup_fetch 
counts can be different even without any use of bitmap scans, because 
.I idx_tup_read 
counts index entries retrieved from the index while 
.I idx_tup_fetch 
counts live rows fetched from the table. The latter will be less if any dead or not-yet-committed rows are fetched using the index, or if any heap fetches are avoided by means of an index-only scan.
.nf
Used query: SELECT
                s.schemaname ||'.'|| s.relname as relation, s.indexrelname AS index,
                s.idx_scan, s.idx_tup_read, s.idx_tup_fetch,
                i.idx_blks_read * (SELECT current_setting('block_size')::int / 1024) AS idx_read,
                i.idx_blks_hit * (SELECT current_setting('block_size')::int / 1024) AS idx_hit
            FROM
                pg_stat_user_indexes s,
                pg_statio_user_indexes i
            WHERE s.indexrelid = i.indexrelid ORDER BY 1;
.fi

.B relation
.RS
.RS
Name of the table for this index including schemaname.
.RE

.B index
.RS
Name of this index.
.RE

.B idx_scan
.RS
Number of index scans per second initiated on this index.
.RE

.B idx_tup_read
.RS
Number of index entries returned per second by scans on this index.
.RE

.B idx_tup_fetch
.RS
Number of live table rows fetched per second by simple index scans using this index.
.RE

.B idx_read
.RS
Number of disk blocks read per second from this index.
.RE

.B idx_hit
.RS
Number of buffer hits per second in this index.
.RE
.RE

.IP "\fBpg_tables_size context\fR"
Show statistics about tables sizes. For taking information about size of relations use
.I pg_stat_user_tables
(or
.IR pg_stat_all_tables )
view,
.I pg_class
system catalog and
.IR pg_relation_size() ,
.I pg_total_relation_size()
functions.
.nf
Used query: SELECT
        s.schemaname ||'.'|| s.relname AS relation,
        pg_total_relation_size((s.schemaname ||'.'|| s.relname)::regclass) / 1024 AS total_size,
        pg_relation_size((s.schemaname ||'.'|| s.relname)::regclass) / 1024 AS rel_size,
        (pg_total_relation_size((s.schemaname ||'.'|| s.relname)::regclass) / 1024) -
            (pg_relation_size((s.schemaname ||'.'|| s.relname)::regclass) / 1024) AS idx_size,
        pg_total_relation_size((s.schemaname ||'.'|| s.relname)::regclass) / 1024 AS total_change,
        pg_relation_size((s.schemaname ||'.'|| s.relname)::regclass) / 1024 AS rel_change,
        (pg_total_relation_size((s.schemaname ||'.'|| s.relname)::regclass) / 1024) -
            (pg_relation_size((s.schemaname ||'.'|| s.relname)::regclass) / 1024) AS idx_change
        FROM pg_stat_user_tables s, pg_class c WHERE s.relid = c.oid ORDER BY 1;
.fi

.B relation
.RS
.RS
Name of this table including schema name.
.RE

.B total_size
.RS
Total size of relation including indexes, in kilobytes.
.RE

.B rel_size
.RS
Size of relation without indexes, in kilobytes.
.RE

.B idx_size
.RS
Size of all indexes of relation, in kilobytes.
.RE

.B total_change
.RS
Relation and indexes size changes in kilobytes per second.
.RE

.B rel_change
.RS
Only relation size changes in kilobytes per second.
.RE

.B idx_change
.RS
Only indexes size changes in kilobytes per second.
.RE
.RE

.IP "\fBpg_stat_activity context\fR"
Show process activity from
.I pg_stat_activity
which have one row per server process, showing information related to the current activity of that process. Show process which runs too long. Default threshold is 10 seconds, and can be changed with
.B A
hotkey. Idle process not displaying. Note: The
.I waiting
and
.I state
columns are independent. If a backend is in the active state, it may or may not be waiting. If the state is active and waiting is true, it means that a query is being executed, but is being blocked by a lock somewhere in the system.
.nf
Used query: SELECT
                pid, client_addr AS cl_addr, client_port AS cl_port,
                datname, usename, state, waiting,
                date_trunc('seconds', clock_timestamp() - xact_start) AS xact_age,
                date_trunc('seconds', clock_timestamp() - query_start) AS query_age,
                date_trunc('seconds', clock_timestamp() - state_change) AS change_age,
                query
            FROM pg_stat_activity
            WHERE ((clock_timestamp() - xact_start) > '00:00:10'::interval
                   OR (clock_timestamp() - query_start) > '00:00:10'::interval) 
            AND state <> 'idle' AND pid <> pg_backend_pid()
            ORDER BY COALESCE(xact_start, query_start);
.fi

.B pid
.RS
.RS
Process ID of this backend.
.RE

.B cl_addr
.RS
IP address of the client connected to this backend. If this field is null, it indicates either that the client is connected via a Unix socket on the server machine or that this is an internal process such as autovacuum.
.RE

.B cl_port
.RS
TCP port number that the client is using for communication with this backend, or -1 if a Unix socket is used.
.RE

.B datname
.RS
Name of the database this backend is connected to.
.RE

.B usename
.RS
Name of the user logged into this backend.
.RE

.B state
.RS
Current overall state of this backend. Possible values are:
.RS
.RE

.B active
.RS
The backend is executing a query.
.RE

.B idle
.RS
The backend is waiting for a new client command.
.RE

.B "idle in transaction"
.RS
The backend is in a transaction, but is not currently executing a query.
.RE

.B "idle in transaction (aborted)"
.RS
This state is similar to idle in transaction, except one of the statements in the transaction caused an error.
.RE

.B "fastpath function call"
.RS
The backend is executing a fast-path function.
.RE

.B disabled
.RS
This state is reported if 
.I track_activities
is disabled in this backend.
.RE
.RE

.B backend_type
.RS
Type of current backend. Possible types are autovacuum launcher, autovacuum worker, background worker, background writer, client backend, checkpointer, startup, walreceiver, walsender and walwriter. Available since PostgreSQL 10.
.RE

.B waiting
.RS
True if this backend is currently waiting on a lock.
.RE

.B xact_age
.RS
Age of transaction started within current process, or null if no transaction is active. If the current query is the first of its transaction, this column is equal to the query_age column.
.RE

.B query_age
.RS
Age of currently active query, or if state is not active, when the last query was started.
.RE

.B change_age
.RS
Age since when the 
.I state
was last changed.
.RE

.B query
.RS
Text of this backend's most recent query. If 
.I state
is active this field shows the currently executing query. In all other states, it shows the last query that was executed.
.RE
.RE

.IP "\fBpg_stat_functions context\fR"
Show statistics from 
.I pg_stat_user_function
view which contain one row for each tracked function, showing statistics about executions of that function. The
.I track_functions
parameter in 
.I postgresql.conf
controls exactly which functions are tracked.
.nf
Used query: SELECT
                funcid, schemaname ||'.'||funcname AS function,
                calls AS total_calls, calls AS calls,
                date_trunc('seconds', total_time / 1000 * '1 second'::interval) AS total_t,
                date_trunc('seconds', self_time / 1000 * '1 second'::interval) AS self_t,
                round((total_time / calls)::numeric, 4) AS avg_t,
                round((self_time / calls)::numeric, 4) AS avg_self_t
            FROM pg_stat_user_functions ORDER BY x DESC;
.fi

.B funcid
.RS
.RS
Unique OID of a function.
.RE

.B function
.RS
Name of this function, including schema name.
.RE

.B total_calls
.RS
Number of times this function has been called.
.RE

.B calls
.RS
Number of times this function has been called per second.
.RE

.B total_t
.RS
Total time spent in this function and all other functions called by it.
.RE

.B self_t
.RS
Total time spent in this function itself, not including other functions called by it.
.RE

.B avg_t
.RS
Average time spent in this function and all other functions called by it, in milliseconds.
.RE

.B avg_self_t
.RS
Average time spent in this function itself, not including other functions called by it, in milliseconds.
.RE
.RE

.IP "\fBpg_stat_statements_timing context\fR"
Show timing statistics from pg_stat_statements module which tracking execution statistics of all SQL statements executed by a server. The module must be loaded by adding
.I pg_stat_statements
to
.I shared_preload_libraries 
in 
.IR postgresql.conf .
This means that a server restart is needed to add or remove the module. When module loaded,
.I pg_stat_statement
extension must be installed in target database. For more information see http://www.postgresql.org/docs/9.4/static/pgstatstatements.html. Additionally used
.I pg_roles
and
.I pg_database
views. Different versions of the PostgreSQL may have different number of fields.
.nf
Used query: SELECT
        a.rolname AS user, d.datname AS database,
        date_trunc('seconds', round(sum(p.total_time)) / 1000 * '1 second'::interval) AS t_all_t,
        date_trunc('seconds', round(sum(p.blk_read_time)) / 1000 * '1 second'::interval) AS t_read_t,
        date_trunc('seconds', round(sum(p.blk_write_time)) / 1000 * '1 second'::interval) AS t_write_t,
        date_trunc('seconds', round((sum(p.total_time) - (sum(p.blk_read_time) + sum(p.blk_write_time)))) / 1000 * '1 second'::interval) AS tot_cpu_t,
        round(sum(p.total_time)) AS all_t,
        round(sum(p.blk_read_time)) AS read_t,
        round(sum(p.blk_write_time)) AS write_t,
        round((sum(p.total_time) - (sum(p.blk_read_time) + sum(p.blk_write_time)))) AS cpu_t,
        sum(p.calls) AS calls,
        left(md5(d.datname || a.rolname || p.query ), 10) AS queryid,
        regexp_replace(
        regexp_replace(
        regexp_replace(
        regexp_replace(
        regexp_replace(p.query,
            E'\\\\?(::[a-zA-Z_]+)?( *, *\\\\?(::[a-zA-Z_]+)?)+', '?', 'g'),
            E'\\\\$[0-9]+(::[a-zA-Z_]+)?( *, *\\\\$[0-9]+(::[a-zA-Z_]+)?)*', '$N', 'g'),
            E'--.*$', '', 'ng'),
            E'/\\\\*.*?\\\\*\\/', '', 'g'),
            E'\\\\s+', ' ', 'g') AS query
    FROM pg_stat_statements p
    JOIN pg_roles a ON a.oid=p.userid
    JOIN pg_database d ON d.oid=p.dbid
    WHERE d.datname != 'postgres' AND calls > 50
    GROUP BY a.rolname, d.datname, query;
.fi

.B user
.RS
.RS
User who executed the statement.
.RE

.B database
.RS
Database in which the statement was executed.
.RE

.B t_all_t
.RS
Total time spent in the statement since last stats reset.
.RE

.B t_read_t
.RS
Total time the statement spent reading blocks (if 
.I track_io_timing
is enabled, otherwise zero) since last stats reset.
.RE

.B t_write_t
.RS
Total time the statement spent writing blocks (if
.I track_io_timing
is enabled, otherwise zero) since last stats reset.
.RE

.B t_cpu_t
.RS
Total time the statement spent in CPU cycling (if
.I track_io_timing
is enabled, otherwise equals 
.BR total_t )
since last stats reset.
.RE

.B all_t
.RS
Current time spent in the statement in ms.
.RE

.B read_t
.RS
Current time the statement spent reading blocks (if 
.I track_io_timing
is enabled, otherwise zero) in ms.
.RE

.B write_t
.RS
Total time the statement spent writing blocks (if
.I track_io_timing
is enabled, otherwise zero) in ms.
.RE

.B cpu_t
.RS
Total time the statement spent in CPU cycling, (if
.I track_io_timing
is enabled, otherwise equals 
.BR total_t )
in ms.
.RE

.B calls
.RS
Current number of query calls.
.RE

.B queryid
.RS
Query ID generated with MD5 hash function and truncated to 10 symbols. Hash based on username, dbname and query text.
.RE

.B query
.RS
Text of a representative statement.
.RE
.RE

.IP "\fBpg_stat_statements_general context\fR"
Show general statistics about rows and calls from pg_stat_statements module which tracking execution statistics of all SQL statements executed by a server. The module must be loaded by adding
.I pg_stat_statements
to
.I shared_preload_libraries 
in 
.IR postgresql.conf .
This means that a server restart is needed to add or remove the module. When module loaded,
.I pg_stat_statement
extension must be installed in target database. For more information see http://www.postgresql.org/docs/9.4/static/pgstatstatements.html. Additionally used
.I pg_roles
and
.I pg_database
views.
.nf
Used query: SELECT
        a.rolname AS user, d.datname AS database,
        sum(p.calls) AS t_calls, sum(p.rows) as t_rows,
        sum(p.calls) AS calls, sum(p.rows) as rows,
        left(md5(d.datname || a.rolname || p.query ), 10) AS queryid,
        regexp_replace(
        regexp_replace(
        regexp_replace(
        regexp_replace(
        regexp_replace(p.query,
            E'\\\\?(::[a-zA-Z_]+)?( *, *\\\\?(::[a-zA-Z_]+)?)+', '?', 'g'),
            E'\\\\$[0-9]+(::[a-zA-Z_]+)?( *, *\\\\$[0-9]+(::[a-zA-Z_]+)?)*', '$N', 'g'),
            E'--.*$', '', 'ng'),
            E'/\\\\*.*?\\\\*\\/', '', 'g'),
            E'\\\\s+', ' ', 'g') AS query
    FROM pg_stat_statements p
    JOIN pg_roles a ON a.oid=p.userid
    JOIN pg_database d ON d.oid=p.dbid
    WHERE d.datname != 'postgres' AND calls > 50
    GROUP BY a.rolname, d.datname, query;
.fi

.B user
.RS
.RS
User who executed the statement.
.RE

.B database
.RS
Database in which the statement was executed.
.RE

.B t_calls
.RS
Total number of times the statement was executed.
.RE

.B t_rows
.RS
Total number of rows retrieved or affected by the statement.
.RE

.B calls
.RS
Number of times the statement was executed per second.
.RE

.B rows
.RS
Number of rows retrieved or affected by the statement per second.
.RE

.B queryid
.RS
Query ID generated with MD5 hash function and truncated to 10 symbols. Hash based on username, dbname and query text.
.RE

.B query
.RS
Text of a representative statement
.RE
.RE

.IP "\fBpg_stat_statements_io context\fR"
Show statistics about buffer input/output from pg_stat_statements module which tracking execution statistics of all SQL statements executed by a server. The module must be loaded by adding
.I pg_stat_statements
to
.I shared_preload_libraries 
in 
.IR postgresql.conf .
This means that a server restart is needed to add or remove the module. When module loaded,
.I pg_stat_statement
extension must be installed in target database. For more information see http://www.postgresql.org/docs/9.4/static/pgstatstatements.html. Additionally used
.I pg_roles
and
.I pg_database
views.
.nf
Used query: SELECT
        a.rolname AS user, d.datname AS database,
        (sum(p.shared_blks_hit) + sum(p.local_blks_hit))
            * (SELECT current_setting('block_size')::int / 1024) as t_hits,
        (sum(p.shared_blks_read) + sum(p.local_blks_read))
            * (SELECT current_setting('block_size')::int / 1024) as t_reads,
        (sum(p.shared_blks_dirtied) + sum(p.local_blks_dirtied))
            * (SELECT current_setting('block_size')::int / 1024) as t_dirtied,
        (sum(p.shared_blks_written) + sum(p.local_blks_written))
            * (SELECT current_setting('block_size')::int / 1024) as t_written,
        (sum(p.shared_blks_hit) + sum(p.local_blks_hit))
            * (SELECT current_setting('block_size')::int / 1024) as hits,
        (sum(p.shared_blks_read) + sum(p.local_blks_read))
            * (SELECT current_setting('block_size')::int / 1024) as reads,
        (sum(p.shared_blks_dirtied) + sum(p.local_blks_dirtied))
            * (SELECT current_setting('block_size')::int / 1024) as dirtied,
        (sum(p.shared_blks_written) + sum(p.local_blks_written))
            * (SELECT current_setting('block_size')::int / 1024) as written,
        sum(p.calls) AS calls,
        left(md5(d.datname || a.rolname || p.query ), 10) AS queryid,
        regexp_replace(
        regexp_replace(
        regexp_replace(
        regexp_replace(
        regexp_replace(p.query,
            E'\\\\?(::[a-zA-Z_]+)?( *, *\\\\?(::[a-zA-Z_]+)?)+', '?', 'g'),
            E'\\\\$[0-9]+(::[a-zA-Z_]+)?( *, *\\\\$[0-9]+(::[a-zA-Z_]+)?)*', '$N', 'g'),
            E'--.*$', '', 'ng'),
            E'/\\\\*.*?\\\\*\\/', '', 'g'),
            E'\\\\s+', ' ', 'g') AS query
    FROM pg_stat_statements p
    JOIN pg_roles a ON a.oid=p.userid
    JOIN pg_database d ON d.oid=p.dbid
    WHERE d.datname != 'postgres' AND calls > 50
    GROUP BY a.rolname, d.datname, query;
.fi

.B user
.RS
.RS
User who executed the statement.
.RE

.B database
.RS
Database in which the statement was executed.
.RE

.B t_hits
.RS
Total amount of shared and local data hits from cache by the statement since stats reset, in Kbytes.
.RE

.B t_reads
.RS
Total amount of shared and local data read by the statement since stats reset, in Kbytes.
.RE

.B t_dirtied
.RS
Total amount of shared and local data dirtied by the statement since stats reset, in Kbytes.
.RE

.B t_written
.RS
Total amount of shared and local data written by the statement since stats reset, in Kbytes.
.RE

.B hits
.RS
Amount of shared and local data hits from cache by the statement per interval (default 1 second), in Kbytes.
.RE

.B reads
.RS
Amount of shared and local data read by the statement per interval (default 1 second), in Kbytes.
.RE

.B dirtied
.RS
Amount of shared and local data dirtied by the statement per interval (default 1 second), in Kbytes.
.RE

.B written
.RS
Amount of shared and local data written by the statement per interval (default 1 second), in Kbytes.
.RE

.B calls
.RS
Number of rows retrieved or affected by the statement per interval.
.RE

.B queryid
.RS
Query ID generated with MD5 hash function and truncated to 10 symbols. Hash based on username, dbname and query text.
.RE

.B query
.RS
Text of a representative statement
.RE
.RE

.IP "\fBpg_stat_statements_temp context\fR"
Show statistics about buffers input/output related with temporary buffers. Stats read from pg_stat_statements module which tracking execution statistics of all SQL statements executed by a server. The module must be loaded by adding
.I pg_stat_statements
to
.I shared_preload_libraries 
in 
.IR postgresql.conf .
This means that a server restart is needed to add or remove the module. When module loaded,
.I pg_stat_statement
extension must be installed in target database. For more information see http://www.postgresql.org/docs/9.4/static/pgstatstatements.html. Additionally used
.I pg_roles
and
.I pg_database
views.
.nf
Used query: SELECT
        a.rolname AS user, d.datname AS database,
        sum(p.temp_blks_read)
            * (SELECT current_setting('block_size')::int / 1024) as t_tmp_read,
        sum(p.temp_blks_written)
            * (SELECT current_setting('block_size')::int / 1024) as t_tmp_write,
        sum(p.temp_blks_read)
            * (SELECT current_setting('block_size')::int / 1024) as tmp_read,
        sum(p.temp_blks_written)
            * (SELECT current_setting('block_size')::int / 1024) as tmp_write,
        sum(p.calls) AS calls,
        left(md5(d.datname || a.rolname || p.query ), 10) AS queryid,
        regexp_replace(
        regexp_replace(
        regexp_replace(
        regexp_replace(
        regexp_replace(p.query,
            E'\\\\?(::[a-zA-Z_]+)?( *, *\\\\?(::[a-zA-Z_]+)?)+', '?', 'g'),
            E'\\\\$[0-9]+(::[a-zA-Z_]+)?( *, *\\\\$[0-9]+(::[a-zA-Z_]+)?)*', '$N', 'g'),
            E'--.*$', '', 'ng'),
            E'/\\\\*.*?\\\\*\\/', '', 'g'),
            E'\\\\s+', ' ', 'g') AS query
    FROM pg_stat_statements p
    JOIN pg_roles a ON a.oid=p.userid
    JOIN pg_database d ON d.oid=p.dbid
    WHERE d.datname != 'postgres' AND calls > 50
    GROUP BY a.rolname, d.datname, query;
.fi

.B user
.RS
.RS
User who executed the statement.
.RE

.B database
.RS
Database in which the statement was executed.
.RE

.B t_tmp_read
.RS
Total amount of temp data read by the statement since last stats reset, in Kbytes.
.RE

.B t_tmp_write
.RS
Total amount of temp data written by the statement sice last stats reset, in Kbytes.
.RE

.B tmp_read
.RS
Amount of temp data read by the statement per interval, in Kbytes.
.RE

.B tmp_write
.RS
Amount of temp data written by the statement per interval, in Kbytes.
.RE

.B calls
.RS
Number of times the statement was executed per second.
.RE

.B queryid
.RS
Query ID generated with MD5 hash function and truncated to 10 symbols. Hash based on username, dbname and query text.
.RE

.B query
.RS
Text of a representative statement
.RE
.RE

.IP "\fBpg_stat_statements_local context\fR"
Show statistics about local input/output (backends that use local memory and not shared buffers) from pg_stat_statements module which tracking execution statistics of all SQL statements executed by a server. The module must be loaded by adding
.I pg_stat_statements
to
.I shared_preload_libraries 
in 
.IR postgresql.conf .
This means that a server restart is needed to add or remove the module. When module loaded,
.I pg_stat_statement
extension must be installed in target database. For more information see http://www.postgresql.org/docs/9.4/static/pgstatstatements.html. Additionally used
.I pg_roles
and
.I pg_database
views.
.nf
Used query: SELECT
        a.rolname AS user, d.datname AS database,
        (sum(p.local_blks_hit)) * (SELECT current_setting('block_size')::int / 1024) as t_lo_hits,
        (sum(p.local_blks_read)) * (SELECT current_setting('block_size')::int / 1024) as t_lo_reads,
        (sum(p.local_blks_dirtied)) * (SELECT current_setting('block_size')::int / 1024) as t_lo_dirtied,
        (sum(p.local_blks_written)) * (SELECT current_setting('block_size')::int / 1024) as t_lo_written,
        (sum(p.local_blks_hit)) * (SELECT current_setting('block_size')::int / 1024) as lo_hits,
        (sum(p.local_blks_read)) * (SELECT current_setting('block_size')::int / 1024) as lo_reads,
        (sum(p.local_blks_dirtied)) * (SELECT current_setting('block_size')::int / 1024) as lo_dirtied,
        (sum(p.local_blks_written)) * (SELECT current_setting('block_size')::int / 1024) as lo_written,
        sum(p.calls) AS calls,
        left(md5(d.datname || a.rolname || p.query ), 10) AS queryid,
        regexp_replace(
        regexp_replace(
        regexp_replace(
        regexp_replace(
        regexp_replace(p.query,
            E'\\\\?(::[a-zA-Z_]+)?( *, *\\\\?(::[a-zA-Z_]+)?)+', '?', 'g'),
            E'\\\\$[0-9]+(::[a-zA-Z_]+)?( *, *\\\\$[0-9]+(::[a-zA-Z_]+)?)*', '$N', 'g'),
            E'--.*$', '', 'ng'),
            E'/\\\\*.*?\\\\*\\/', '', 'g'),
            E'\\\\s+', ' ', 'g') AS query
    FROM pg_stat_statements p
    JOIN pg_roles a ON a.oid=p.userid
    JOIN pg_database d ON d.oid=p.dbid
    WHERE d.datname != 'postgres' AND calls > 50
    GROUP BY a.rolname, d.datname, query;
.fi

.B user
.RS
.RS
User who executed the statement.
.RE

.B database
.RS
Database in which the statement was executed.
.RE

.B t_lo_hits
.RS
Total amount of data hits from backends local memory by the statement since stats reset, in Kbytes.
.RE

.B t_lo_reads
.RS
Total amount of data read from backends local memory by the statement since stats reset, in Kbytes.
.RE

.B t_lo_dirtied
.RS
Total amount of data dirtied in backends local memory by the statement since stats reset, in Kbytes.
.RE

.B t_lo_written
.RS
Total amount of data written to backends local memory by the statement since stats reset, in Kbytes.
.RE

.B lo_hits
.RS
Amount of data hits from backends local memory by the statement per interval (default 1 second), in Kbytes.
.RE

.B lo_reads
.RS
Amount of data read from backends local memory by the statement per interval (default 1 second), in Kbytes.
.RE

.B lo_dirtied
.RS
Amount of data dirtied in backends local memory by the statement per interval (default 1 second), in Kbytes.
.RE

.B lo_written
.RS
Amount of data written to backends local memory by the statement per interval (default 1 second), in Kbytes.
.RE

.B calls
.RS
Number of rows retrieved or affected by the statement per interval.
.RE

.B queryid
.RS
Query ID generated with MD5 hash function and truncated to 10 symbols. Hash based on username, dbname and query text.
.RE

.B query
.RS
Text of a representative statement
.RE
.RE

.IP "\fBpg_stat_progress_vacuum context\fR"
Whenever VACUUM is running, the pg_stat_progress_vacuum view will contain one row for each backend (including autovacuum worker processes) that is currently vacuuming. The tables below describe the information that will be reported and provide information about how to interpret it. Progress reporting is not currently supported for VACUUM FULL and backends running VACUUM FULL will not be listed in this view. This statistics are available since PostgreSQL 9.6, for more information see https://www.postgresql.org/docs/9.6/static/progress-reporting.html. Additionally used
.I pg_stat_activity
view.
.nf
Used query:
    SELECT
        a.pid,
        date_trunc('seconds', clock_timestamp() - xact_start) AS xact_age,
        v.datname, v.relid::regclass AS relation,
        a.state, v.phase,
        v.heap_blks_total * (SELECT current_setting('block_size')::int / 1024) AS total,
        v.heap_blks_scanned * (SELECT current_setting('block_size')::int / 1024) AS scanned,
        v.heap_blks_vacuumed * (SELECT current_setting('block_size')::int / 1024) AS vacuumed,
        a.wait_event_type AS wait_etype, a.wait_event,
        a.query
    FROM pg_stat_progress_vacuum v
    JOIN pg_stat_activity a ON v.pid = a.pid
    ORDER BY COALESCE(a.xact_start, a.query_start)
.fi

.B pid
.RS
.RS
Process ID of vacuum.
.RE

.B xact_age
.RS
Age of vacuum task.
.RE

.B datname
.RS
Database name where vacuum worker is connected.
.RE

.B state
.RS
Postgres backend state (see pg_stat_activity backends states).
.RE

.B phase
.RS
Current processing phase of vacuum. See VACUUM phases - https://www.postgresql.org/docs/9.6/static/progress-reporting.html#VACUUM-PHASES.
.RE

.B total
.RS
Total size of the table in Kbytes. This number is reported as of the beginning of the scan; size increased during vacuum will not be (and need not be) shown and this space will not be visited by this VACUUM.
.RE

.B scanned
.RS
Size of table in Kbytes that is scanned. Because the visibility map is used to optimize scans, some blocks will be skipped without inspection; skipped blocks are included in this total, so that this number will eventually become equal to total when the vacuum is complete. This counter only advances when the phase is scanning heap.
.RE

.B vacuumed
.RS
Size of table in Kbytes that is vacuumed. Unless the table has no indexes, this counter only advances when the phase is vacuuming heap. Blocks that contain no dead tuples are skipped, so the counter may sometimes skip forward in large increments.
.RE

.B wait_etype
.RS
The type of event for which the backend is waiting, if any; otherwise NULL.
.RE

.B wait_event
.RS
Wait event name if backend is currently waiting, otherwise NULL.
.RE

.B query
.RS
Text of a representative statement.
.RE
.RE

.SH SUBTABS
Subtab it's a additional area in the current active tab which presents auxilary data which not directly related with the PostgreSQL but may be useful in troubleshoot.

.IP "\fBLogtail subtab\fR"
Opens logfile in subtab and tail this log. Used only if \fBpgcenter\fR and \fBPostgreSQL\fR running on the same host. All multiline log entries truncates to end of line. Requires database superuser privileges.

.IP "\fBiostat subtab\fR"
Report input/output statistics for devices and partitions. The iostat subtab is used for monitoring system input/output device loading by observing the time the devices are active in relation to their average transfer rates. The first report generated by the iostat subtab provides statistics concerning the time since the system was booted.  Each subsequent report covers the time since the previous report. Iostat subtab similar to \fBiostat\fR utility from \fBsysstat\fR package and /proc/diskstats interface. For the proper iostat work /proc filesystem must be mounted for iostat to work. Kernels older than 2.6.x are not supported.

.B Device
.RS
.RS
Block device registered in a system.
.RE

.B rrqm/s
.RS
The number of read requests merged per second that were queued to the device.
.RE

.B wrqm/s
.RS
The number of write requests merged per second that were queued to the device.
.RE

.B r/s
.RS
The number (after merges) of read requests completed per second for the device.
.RE

.B w/s
.RS
The number (after merges) of write requests completed per second for the device.
.RE

.B rMB/s
.RS
The number of megabytes read from the device per second.
.RE

.B wMB/s
.RS
The number of megabytes written to the device per second.
.RE

.B avgrq-sz
.RS
The average size (in sectors) of the requests that were issued to the device.
.RE

.B avgqu-sz
.RS
The average queue length of the requests that were issued to the device.
.RE

.B await
.RS
The average time (in milliseconds) for I/O requests issued to the device to be served. This includes the time spent by the requests in queue and the time spent servicing them.
.RE

.B r_await
.RS
The average time (in milliseconds) for read requests issued to the device to be served. This includes the time spent by the requests in queue and the time spent servicing them.
.RE

.B w_await
.RS
The average time (in milliseconds) for write requests issued to the device to be served. This includes the time spent by the requests in queue and the time spent servicing them.
.RE

.B %util
.RS
Percentage of elapsed time during which I/O requests were issued to the device (bandwidth utilization for the device). Device saturation occurs when this value is close to 100% for devices serving requests serially.  But for devices serving requests in parallel, such as RAID arrays and modern SSDs, this number does not reflect their performance limits.
.RE
.RE

.IP "\fBnicstat subtab\fR"
Print network traffic statistics for all network cards (NICs), including packets, kilobytes per second, average packet sizes and more. Nicstat subtab similar to nicstat utility and use /proc/net/dev interface.

.B Interface
.RS
.RS
Network interface registered in a system.
.RE

.B rMbps
.RS
Megabits per interval read (received).
.RE

.B wMbps
.RS
Megabits per interval written (transmitted).
.RE

.B rPk/s
.RS
Packets per interval read (received).
.RE

.B wPk/s
.RS
Packets per interval written (transmitted).
.RE

.B rAvs
.RS
Average size of packets read (received).
.RE

.B wAvs
.RS
Average size of packets written (transmitted).
.RE

.B IErr
.RS
Packets received that could not be processed because they contained errors.
.RE

.B OErr
.RS
Packets that were not successfully transmitted because of errors.
.RE

.B Coll
.RS
Ethernet collisions during transmit.
.RE

.B Sat
.RS
Saturation. This the number of errors/second seen for the interface - an indicator the interface may be approaching saturation. This statistic is combined from a number of kernel statistics.
.RE

.B %rUtil
.B %wUtil
.RS
Percentage utilization for bytes read and written, respectively.
.RE

.B %Util
.RS
Percentage utilization of the interface.  For full-duplex interfaces, this is the greater of rMB/s or wMB/s as a percentage of the interface speed. For half-duplex interfaces, rMB/s and wMB/s are summed.
.RE
.RE

.SH INTERACTIVE COMMANDS
The global interactive commands are always available main program mode
.TP 7
\ \ \ \fB1..8\fR\ \ :\fBSwitch tab\fR toggle \fR
Switch between opened tabs. Number of tabs limited by eight.
.TP 7
\ \ \ \fBd\fR\ \ :\fBpg_stat_database\fR toggle \fR
Show statistics from \fBpg_stat_database\fR view. This statistics includes per database info about commits/rollbacks, returned and fetched tuples, write operations such as inserts/deletes/updates, abnormal situations like conflicts and deadlocks, info about temporary files usage and read/write timings.
.TP 7
\ \ \ \fBr\fR\ \ :\fBpg_stat_replication\fR toggle \fR
Show statistics from \fIpg_stat_replication\fR view. Statistics about streaming replication connections, includes information about connected standbys and amount of data which is sent, written, flushed or replayed on standby servers. Also available info about replication lag.
.TP 7
\ \ \ \fBt\fR\ \ :\fBpg_stat_tables\fR toggle \fR
Show statistics from \fIpg_stat_user_tables\fR (or \fIpg_stat_all_tables\fR) view about accesses to that specific tables. Includes sequential/index scans, number of inserted/updated/deleted tuples, number of live/dead tuples. Useful for determine current tables workload. By default, displayed only user tables, displaying system tables can be enabled by pressing \fBV\fR.
.TP 7
\ \ \ \fBT\fR\ \ :\fBpg_statio_tables\fR toggle \fR
Show statistics from \fIpg_statio_user_tables\fR (or \fIpg_statio_all_tables\fR) view about I/O on tables in the current database. Includes info about reads from disk and shared buffers related to tables, their indexes or TOAST. Useful for determine current tables workload. By default, displayed only user tables, displaying system tables can be enabled by pressing \fBV\fR.
.TP 7
\ \ \ \fBi\fR\ \ :\fBpg_stat_indexes\fR toggle \fR
Show statistics from \fIpg_stat_user_indexes\fR and \fIpg_statio_user_indexes\fR (or \fIpg_stat_all_indexes\fR and \fIpg_statio_all_indexes\fR) views which showing statistics about accesses to that specific indexes and their I/O. Includes info about number of index scans, number of readen and fetched tuples, data read from disk or shared buffers. By default, displayed only user indexes, displaying system indexes can be enabled by pressing \fBV\fR. Useful for determine index usage.
.TP 7
\ \ \ \fBs\fR\ \ :\fBpg_tables_size\fR toggle \fR
Show statistics about tables and their indexes sizes. For taking information about size of relations use \fIpg_stat_user_tables\fR (or \fIpg_stat_all_tables\fR) view, \fIpg_class\fR system catalog and \fIpg_relation_size()\fR, \fIpg_total_relation_size()\fR functions.
.TP 7
\ \ \ \fBa\fR\ \ :\fBpg_stat_activity\fR toggle \fR
Show statistics about long queries from \fIpg_stat_activity\fR view. Show information about client (address, port, name, database), text of query and his state and age. Default age threshold is 10 seconds, and can be changed with \fBA\fR hotkey.
.TP 7
\ \ \ \fBf\fR\ \ :\fBpg_stat_functions\fR toggle \fR
Show statistics from \fIpg_stat_user_functions\fR view about tracked functions and their executions, such as number of calls and execution time. The \fItrack_functions\fR parameter in \fIpostgresql.conf\fR controls exactly which functions are tracked.
.TP 7
\ \ \ \fBv\fR\ \ :\fBpg_stat_progress_vacuum\fR toggle \fR
Show statistics from \fIpg_stat_progress_vacuum\fR view about vacuum execution progress. Available since PostgreSQL 9.6.
.TP 7
\ \ \ \fBx\fR\ \ :\fBSwitch to next pg_stat_statements context\fR toggle \fR
Switches between \fBpg_stat_statements\fR contexts: timings, general, input/output, temporary input/output, local input/output.
.TP 7
\ \ \ \fBX\fR\ \ :\fBShow pg_stat_statements menu\fR toggle \fR
Open pg_stat_statements menu and allow to choose pg_stat_statements context without switching.
.TP 7
\ \ \ \fBE\fR\ \ :\fBEdit configuration files menu\fR toggle \fR
Open configuration files menu and edit specific config. Supported editing of postgresql.conf, pg_hba.conf, pg_ident.conf and recovery.conf. Used only if \fBpgcenter\fR and \fBPostgreSQL\fR running on the same host. Use $EDITOR environment variable or \fBvi\fR by default. Requires database superuser privileges.
.TP 7
\ \ \ \fBC\fR\ \ :\fBShow current configuration\fR toggle \fR
Show current \fBPostgreSQL\fR configuration from \fIpg_settings\fR view. For viewing all parameters requires database superuser privileges.
.TP 7
\ \ \ \fBR\fR\ \ :\fBReload\fR toggle \fR
Reload \fBPostgreSQL\fR service for apply configuration changes. The \fBpgcenter\fR used \fIpg_reload_conf()\fR function for reloading. Requires database superuser privileges.
.TP 7
\ \ \ \fBp\fR\ \ :\fBStart psql session\fR toggle \fR
Start \fBpsql\fR session with current connection settings.
.TP 7
\ \ \ \fBB\fR\ \ :\fBOpen iostat subtab\fR toggle \fR
Open subtab with iostat which reporting input/output statistics for devices and partitions. Show statistics from current host.
.TP 7
\ \ \ \fBI\fR\ \ :\fBOpen nicstat subtab\fR toggle \fR
Open subtab with nicstat which reporting network statistics for all network cards (NICs), including packets, kilobytes per second, average packet sizes and more.. Show statistics from current host.
.TP 7
\ \ \ \fBL\fR\ \ :\fBOpen logtail subtab\fR toggle \fR
Open subtab and tail postgresql log. Used only if \fBpgcenter\fR and \fBPostgreSQL\fR running on the same host. Requires database superuser privileges.
.TP 7
\ \ \ \fBl\fR\ \ :\fBOpen log file\fR toggle \fR
Open logfile with pager. Use $PAGER environment variable or \fBless\fR by default. Used only if \fBpgcenter\fR and \fBPostgreSQL\fR running on the same host. Requires database superuser privileges.
.TP 7
\ \ \ \fBN\fR\ \ :\fBOpen new connection\fR toggle \fR
Open new connection to \fBPostgreSQL\fR in a new tab. Specify host, port, user, dbname options and pgcenter will try to connect using these connection settings.
.TP 7
\ \ \ \fBCtrl+D\fR\ \ :\fBClose current connection\fR toggle \fR
Close current tab and connection.
.TP 7
\ \ \ \fBW\fR\ \ :\fBWrite connection options\fR toggle \fR
Write connection settings into config file. By default is \fI~/.pgcenterrc\fR is used. If \fB--file=FILENAME\fR argument was used at \fBpgcenter\fR start, connection settings will be written at specified file.
.TP 7
\ \ \ \fBLeft, Right\fR\ \ :\fBChange sort\fR toggle \fR
Change column which is used for sort.
.TP 7
\ \ \ \fB/\fR\ \ :\fBChange sort order\fR toggle \fR
Change sort order, descent or ascent. Descent order used by default.
.TP 7
\ \ \ \fBF\fR\ \ :\fBSet filtration\fR toggle \fR
Set filter pattern for a column, or reset filtration with empty value. Note, filter patterns are remebered between tab and context switches. Filtered column marked with \fB*\fR symbol. No filtration by default.
.TP 7
\ \ \ \fB-\fR\ \ :\fBCancel backend\fR toggle \fR
Cancel query execution using backend pid with \fIpg_cancel_backend()\fR function. This function allowed only when \fBpg_stat_activity\fR context enabled by \fBa\fR hotkey. Requires database superuser privileges.
.TP 7
\ \ \ \fB_\fR\ \ :\fBTerminate backend\fR toggle \fR
Terminate process using backend pid with \fBpg_terminate_backend()\fR function. This function allowed only when \fBpg_stat_activity\fR context enabled by \fBa\fR hotkey. Requires database superuser privileges.
.TP 7
\ \ \ \fBDel\fR\ \ :\fBCancel group of backends\fR toggle \fR
Cancel queries execution in group of backends with \fBpg_cancel_backend()\fR function. Group of backends determined using mask which specified by \fBn\fR toggle. Note, queries are canceled without confirmation. This function allowed only when \fBpg_stat_activity\fR context enabled by \fBa\fR hotkey. Unprivileged users can cancel their own queries. Superusers can cancel any queries. Backend pids which queries will be canceled are selected from \fBpg_stat_activity\fR view, select condition determined by mask which can be defined with \fBn\fR hotkey.
.TP 7
\ \ \ \fBShift+Del\fR\ \ :\fBTerminate group of backends\fR toggle \fR
Terminate queries execution in group of backends with \fBpg_terminate_backend()\fR function. Group of backends determined using mask which specified by \fBn\fR toggle. Note, backends are terminated without confirmation. This function allowed only when \fBpg_stat_activity\fR context enabled by \fBa\fR hotkey. Unprivileged users can terminate their own backends. Superusers can terminate any backends. Backend pids which will be terminated are selected from \fBpg_stat_activity\fR view, select condition determined by mask which can be defined with \fBn\fR hotkey.
.TP 7
\ \ \ \fBn\fR\ \ :\fBSet new mask\fR toggle \fR
Set new mask for group cancel/terminate. Type of backends associated with their states:

.B active
.RS
.RS
Backend which are executing a queries.
.nf
Used condition: WHERE state = 'active' AND (
                    (clock_timestamp() - xact_start) > '00:00:10.0'::interval 
                     OR 
                    (clock_timestamp() - query_start) > '00:00:10.0'::interval
                ) AND pid <> pg_backend_pid();
.fi
.RE

.B idle
.RS
Backends which are do nothing and waiting for a new client command.
.nf
Used confition: WHERE state = 'idle' AND (
                    (clock_timestamp() - xact_start) > '00:00:10.0'::interval 
                     OR 
                    (clock_timestamp() - query_start) > '00:00:10.0'::interval
                ) AND pid <> pg_backend_pid();
.fi
.RE

.B idle_in_xact
.RS
Includes \fBidle in transaction\fR and \fBidle in transaction: (aborted)\fR states. Always a bad state.
.nf
Used condition: WHERE state IN ('idle in transaction (aborted)', 'idle in transaction') AND (
                    (clock_timestamp() - xact_start) > '00:00:10.0'::interval
                     OR
                    (clock_timestamp() - query_start) > '00:00:10.0'::interval)
                AND pid <> pg_backend_pid();
.fi
.RE

.B waiting
.RS
Backends which are currently waiting on a lock. Long waiting transactions or statements are bad.
.nf
Used condition: WHERE waiting AND (
                    (clock_timestamp() - xact_start) > '00:00:10.0'::interval
                     OR (clock_timestamp() - query_start) > '00:00:10.0'::interval
                ) AND pid <> pg_backend_pid();
.fi
.RE

.B other
.RS
backends which are executing a \fBfast-path function call\fR or with \fBdisabled\fR state - when \fItrack_activities\fR are disabled in those backends.
.nf
Used condition: WHERE state IN ('fastpath function call', 'disabled') AND (
                    (clock_timestamp() - xact_start) > '00:00:10.0'::interval
                     OR (clock_timestamp() - query_start) > '00:00:10.0'::interval
                ) AND pid <> pg_backend_pid();
.fi
.RE

A ten seconds interval used in condition determines query or transaction age and can be overriden with \fBA\fR hotkey.

Note, \fBwaiting\fR is not a backend state. If a backend is in the active state, it may or may not be waiting. If the state is active and waiting is true, it means that a query is being executed, but is being blocked by a lock somewhere in the system. Therefore, if \fBwaiting\fR added to the mask, all waiting queries will be canceled ot terminated independently of his backends states.
.RE

.TP 7
\ \ \ \fBm\fR\ \ :\fBDisplay current mask\fR toggle \fR
Show current mask which will used for group cancel/terminate.
.TP 7
\ \ \ \fBA\fR\ \ :\fBChange age threshold\fR toggle \fR
Change age threshold for long running queries. Queries which age is never then threshold not displayed. Default threshold 10 seconds. This function allowed only when \fBpg_stat_activity\fR context enabled by \fBa\fR hotkey.
.TP 7
\ \ \ \fBV\fR\ \ :\fBShow system tables\fR toggle \fR
Toggle on/off system tables and indexes. By default, the pgcenter shows table/index statistics for user tables from \fIpg_stat_user_*\fR views. 
.TP 7
\ \ \ \fBK\fR\ \ :\fBReset postgresql stats\fR toggle \fR
Reset \fBPostgreSQL\fR stats counters for the current database to zero. The \fIpg_stat_statements\fR counters also reseted. Requires database superuser privileges.
.TP 7
\ \ \ \fBG\fR\ \ :\fBGet query report\fR toggle \fR
Show query report with various information about specified query. This function work only in \fBpg_stat_statements_timing\fR and \fBpg_stat_statements_general\fR contexts. For specifying query use id values from \fBqueryid\fR column.
.TP 7
\ \ \ \fBz\fR\ \ :\fBChange refresh interval\fR toggle \fR
You will be prompted to enter the delay time, in seconds, between display updates. Can not be less that 1 second.
.TP 7
\ \ \ \fBZ\fR\ \ :\fBChange Color Mapping\fR toggle \fR
This key will take you to a separate config screen where you can change the colors for the windows.
.TP 7
\ \ \ \fBspace\fR\ \ :\fBPause program execution\fR toggle \fR
.TP 7
\ \ \ \fBF1\fR\ \ :\fBHelp\fR toggle \fR
Show help screen.
.TP 7
\ \ \ \fBq\fR\ \ :\fBQuit\fR

.SH URLS
.IP "pg_stat_statements module"
http://www.postgresql.org/docs/9.4/static/pgstatstatements.html
.IP "PostgreSQL statistics collector"
http://www.postgresql.org/docs/9.4/static/monitoring-stats.html

.SH BUGS
To report bugs, use http://github.com/lesovsky/pgbconsole/issues page

.SH AUTHOR
Alexey Lesovsky, <lesovsky@gmail.com>

.SH SEE ALSO
.BR 
.br
